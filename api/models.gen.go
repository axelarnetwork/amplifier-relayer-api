// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"encoding/json"
	"errors"
	"fmt"
	"time"

	uuid "github.com/google/uuid"
	"github.com/oapi-codegen/runtime"
)

// Defines values for BroadcastStatus.
const (
	BroadcastStatusError    BroadcastStatus = "ERROR"
	BroadcastStatusReceived BroadcastStatus = "RECEIVED"
	BroadcastStatusSuccess  BroadcastStatus = "SUCCESS"
)

// Defines values for CannotExecuteMessageReason.
const (
	CannotExecuteMessageReasonError           CannotExecuteMessageReason = "ERROR"
	CannotExecuteMessageReasonInsufficientGas CannotExecuteMessageReason = "INSUFFICIENT_GAS"
)

// Defines values for CannotExecuteTaskReason.
const (
	CannotExecuteTaskReasonCustom          CannotExecuteTaskReason = "CUSTOM"
	CannotExecuteTaskReasonError           CannotExecuteTaskReason = "ERROR"
	CannotExecuteTaskReasonInsufficientGas CannotExecuteTaskReason = "INSUFFICIENT_GAS"
	CannotExecuteTaskReasonTxReverted      CannotExecuteTaskReason = "TX_REVERTED"
)

// Defines values for CannotRouteMessageReason.
const (
	CannotRouteMessageReasonCustom CannotRouteMessageReason = "CUSTOM"
	CannotRouteMessageReasonError  CannotRouteMessageReason = "ERROR"
)

// Defines values for EventType.
const (
	EventTypeAppInterchainTransferReceived       EventType = "APP/INTERCHAIN_TRANSFER_RECEIVED"
	EventTypeAppInterchainTransferSent           EventType = "APP/INTERCHAIN_TRANSFER_SENT"
	EventTypeCall                                EventType = "CALL"
	EventTypeCannotExecuteMessage                EventType = "CANNOT_EXECUTE_MESSAGE"
	EventTypeCannotExecuteMessageV2              EventType = "CANNOT_EXECUTE_MESSAGE/V2"
	EventTypeCannotExecuteTask                   EventType = "CANNOT_EXECUTE_TASK"
	EventTypeCannotRouteMessage                  EventType = "CANNOT_ROUTE_MESSAGE"
	EventTypeGasCredit                           EventType = "GAS_CREDIT"
	EventTypeGasRefunded                         EventType = "GAS_REFUNDED"
	EventTypeITSInterchainTokenDeploymentStarted EventType = "ITS/INTERCHAIN_TOKEN_DEPLOYMENT_STARTED"
	EventTypeITSInterchainTransfer               EventType = "ITS/INTERCHAIN_TRANSFER"
	EventTypeITSLinkTokenStarted                 EventType = "ITS/LINK_TOKEN_STARTED"
	EventTypeITSTokenMetadataRegistered          EventType = "ITS/TOKEN_METADATA_REGISTERED"
	EventTypeMessageApproved                     EventType = "MESSAGE_APPROVED"
	EventTypeMessageExecuted                     EventType = "MESSAGE_EXECUTED"
	EventTypeMessageExecutedV2                   EventType = "MESSAGE_EXECUTED/V2"
	EventTypeSignersRotated                      EventType = "SIGNERS_ROTATED"
)

// Defines values for MessageExecutionStatus.
const (
	MessageExecutionStatusReverted   MessageExecutionStatus = "REVERTED"
	MessageExecutionStatusSuccessful MessageExecutionStatus = "SUCCESSFUL"
)

// Defines values for PublishEventStatus.
const (
	PublishEventStatusAccepted PublishEventStatus = "ACCEPTED"
	PublishEventStatusError    PublishEventStatus = "ERROR"
)

// Defines values for TaskType.
const (
	TaskTypeConstructProof               TaskType = "CONSTRUCT_PROOF"
	TaskTypeExecute                      TaskType = "EXECUTE"
	TaskTypeGatewayTransaction           TaskType = "GATEWAY_TX"
	TaskTypeReactToExpiredSigningSession TaskType = "REACT_TO_EXPIRED_SIGNING_SESSION"
	TaskTypeReactToRetriablePoll         TaskType = "REACT_TO_RETRIABLE_POLL"
	TaskTypeReactToWasmEvent             TaskType = "REACT_TO_WASM_EVENT"
	TaskTypeRefund                       TaskType = "REFUND"
	TaskTypeVerify                       TaskType = "VERIFY"
)

// Defines values for TokenManagerType.
const (
	TokenManagerLockUnlock            TokenManagerType = "LOCK_UNLOCK"
	TokenManagerLockUnlockFee         TokenManagerType = "LOCK_UNLOCK_FEE"
	TokenManagerMintBurn              TokenManagerType = "MINT_BURN"
	TokenManagerMintBurnFrom          TokenManagerType = "MINT_BURN_FROM"
	TokenManagerNativeInterchainToken TokenManagerType = "NATIVE_INTERCHAIN_TOKEN"
)

// Defines values for VerificationStatus.
const (
	VerificationStatusFailedOnSourceChain    VerificationStatus = "FAILED_ON_SOURCE_CHAIN"
	VerificationStatusFailedToVerify         VerificationStatus = "FAILED_TO_VERIFY"
	VerificationStatusInProgress             VerificationStatus = "IN_PROGRESS"
	VerificationStatusNotFoundOnSourceChain  VerificationStatus = "NOT_FOUND_ON_SOURCE_CHAIN"
	VerificationStatusSucceededOnSourceChain VerificationStatus = "SUCCEEDED_ON_SOURCE_CHAIN"
	VerificationStatusUnknown                VerificationStatus = "UNKNOWN"
)

// Address defines model for Address.
type Address = string

// AppEventMetadata defines model for AppEventMetadata.
type AppEventMetadata struct {
	EmittedByAddress *Address   `json:"emittedByAddress,omitempty"`
	Finalized        *bool      `json:"finalized,omitempty"`
	FromAddress      *Address   `json:"fromAddress,omitempty"`
	Timestamp        *time.Time `json:"timestamp,omitempty"`
	TxID             *string    `json:"txID,omitempty"`
}

// AppInterchainTransferReceivedEvent defines model for AppInterchainTransferReceivedEvent.
type AppInterchainTransferReceivedEvent struct {
	EventID       string                  `json:"eventID"`
	MessageID     string                  `json:"messageID"`
	Meta          *AppEventMetadata       `json:"meta,omitempty"`
	Recipient     Address                 `json:"recipient"`
	Sender        []byte                  `json:"sender"`
	SourceAddress Address                 `json:"sourceAddress"`
	SourceChain   string                  `json:"sourceChain"`
	TokenReceived InterchainTransferToken `json:"tokenReceived"`
}

// AppInterchainTransferSentEvent defines model for AppInterchainTransferSentEvent.
type AppInterchainTransferSentEvent struct {
	DestinationChain           string                  `json:"destinationChain"`
	DestinationContractAddress Address                 `json:"destinationContractAddress"`
	EventID                    string                  `json:"eventID"`
	MessageID                  string                  `json:"messageID"`
	Meta                       *AppEventMetadata       `json:"meta,omitempty"`
	Recipient                  []byte                  `json:"recipient"`
	Sender                     Address                 `json:"sender"`
	TokenSpent                 InterchainTransferToken `json:"tokenSpent"`
}

// BigInt defines model for BigInt.
type BigInt = string

// BroadcastID defines model for BroadcastID.
type BroadcastID = uuid.UUID

// BroadcastResponse defines model for BroadcastResponse.
type BroadcastResponse struct {
	BroadcastID BroadcastID `json:"broadcastID"`
}

// BroadcastStatus defines model for BroadcastStatus.
type BroadcastStatus string

// BroadcastStatusResponse defines model for BroadcastStatusResponse.
type BroadcastStatusResponse struct {
	CompletedAt *time.Time      `json:"completedAt,omitempty"`
	Error       *string         `json:"error,omitempty"`
	ReceivedAt  time.Time       `json:"receivedAt"`
	Status      BroadcastStatus `json:"status"`
	TxEvents    *[]WasmEvent    `json:"txEvents,omitempty"`
	TxHash      *string         `json:"txHash,omitempty"`
}

// CallEvent defines model for CallEvent.
type CallEvent struct {
	DestinationChain string             `json:"destinationChain"`
	EventID          string             `json:"eventID"`
	Message          Message            `json:"message"`
	Meta             *CallEventMetadata `json:"meta,omitempty"`
	Payload          []byte             `json:"payload"`
	WithToken        *Token             `json:"withToken,omitempty"`
}

// CallEventMetadata defines model for CallEventMetadata.
type CallEventMetadata struct {
	Finalized         *bool           `json:"finalized,omitempty"`
	FromAddress       *Address        `json:"fromAddress,omitempty"`
	ParentMessageID   *string         `json:"parentMessageID,omitempty"`
	ParentSourceChain *string         `json:"parentSourceChain,omitempty"`
	SourceContext     *MessageContext `json:"sourceContext,omitempty"`
	Timestamp         *time.Time      `json:"timestamp,omitempty"`
	TxID              *string         `json:"txID,omitempty"`
}

// CannotExecuteMessageEvent defines model for CannotExecuteMessageEvent.
type CannotExecuteMessageEvent struct {
	Details string                             `json:"details"`
	EventID string                             `json:"eventID"`
	Meta    *CannotExecuteMessageEventMetadata `json:"meta,omitempty"`
	// Deprecated:
	Reason     CannotExecuteMessageReason `json:"reason"`
	TaskItemID TaskItemID                 `json:"taskItemID"`
}

// CannotExecuteMessageEventMetadata defines model for CannotExecuteMessageEventMetadata.
type CannotExecuteMessageEventMetadata struct {
	FromAddress *Address   `json:"fromAddress,omitempty"`
	Timestamp   *time.Time `json:"timestamp,omitempty"`
}

// CannotExecuteMessageEventV2 defines model for CannotExecuteMessageEventV2.
type CannotExecuteMessageEventV2 struct {
	Details   string                               `json:"details"`
	EventID   string                               `json:"eventID"`
	MessageID string                               `json:"messageID"`
	Meta      *CannotExecuteMessageEventV2Metadata `json:"meta,omitempty"`
	// Deprecated:
	Reason      CannotExecuteMessageReason `json:"reason"`
	SourceChain string                     `json:"sourceChain"`
}

// CannotExecuteMessageEventV2Metadata defines model for CannotExecuteMessageEventV2Metadata.
type CannotExecuteMessageEventV2Metadata struct {
	FromAddress *Address    `json:"fromAddress,omitempty"`
	TaskItemID  *TaskItemID `json:"taskItemID,omitempty"`
	Timestamp   *time.Time  `json:"timestamp,omitempty"`
}

// CannotExecuteMessageReason defines model for CannotExecuteMessageReason.
type CannotExecuteMessageReason string

// CannotExecuteTaskEvent defines model for CannotExecuteTaskEvent.
type CannotExecuteTaskEvent struct {
	Cost       *Cost                   `json:"cost,omitempty"`
	Details    string                  `json:"details"`
	EventID    string                  `json:"eventID"`
	Meta       *EventMetadata          `json:"meta,omitempty"`
	Reason     CannotExecuteTaskReason `json:"reason"`
	TaskItemID TaskItemID              `json:"taskItemID"`
}

// CannotExecuteTaskReason defines model for CannotExecuteTaskReason.
type CannotExecuteTaskReason string

// CannotRouteMessageEvent defines model for CannotRouteMessageEvent.
type CannotRouteMessageEvent struct {
	Details   string         `json:"details"`
	EventID   string         `json:"eventID"`
	MessageID string         `json:"messageID"`
	Meta      *EventMetadata `json:"meta,omitempty"`
	// Deprecated:
	Reason CannotRouteMessageReason `json:"reason"`
}

// CannotRouteMessageReason defines model for CannotRouteMessageReason.
type CannotRouteMessageReason string

// ConstructProofTask defines model for ConstructProofTask.
type ConstructProofTask struct {
	Message Message `json:"message"`
	Payload []byte  `json:"payload"`
}

// ConstructProofTaskItem defines model for ConstructProofTaskItem.
type ConstructProofTaskItem struct {
	Task ConstructProofTask `json:"task"`
}

// ContractQueryResponse defines model for ContractQueryResponse.
type ContractQueryResponse map[string]interface{}

// Cost defines model for Cost.
type Cost struct {
	union json.RawMessage
}

// CrossChainID defines model for CrossChainID.
type CrossChainID struct {
	MessageID   string `json:"messageID"`
	SourceChain string `json:"sourceChain"`
}

// DestinationChainTaskMetadata Metadata attached to GATEWAY_TX and REACT_TO_EXPIRED_SIGNING_SESSION tasks.
// The property `scopedMessages` can be omitted if the task isn't associated with any message (e.g. when executing `rotateSigners` https://github.com/axelarnetwork/axelar-gmp-sdk-solidity/blob/432449d7b330ec6edf5a8e0746644a253486ca87/contracts/gateway/AxelarAmplifierGateway.sol#L103C14-L103C27).
type DestinationChainTaskMetadata struct {
	ScopedMessages *[]CrossChainID `json:"scopedMessages,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error     string  `json:"error"`
	RequestID *string `json:"requestID,omitempty"`
}

// Event defines model for Event.
type Event struct {
	Type  EventType `json:"type"`
	union json.RawMessage
}

// EventBase defines model for EventBase.
type EventBase struct {
	EventID string         `json:"eventID"`
	Meta    *EventMetadata `json:"meta,omitempty"`
}

// EventMetadata defines model for EventMetadata.
type EventMetadata struct {
	Finalized   *bool      `json:"finalized,omitempty"`
	FromAddress *Address   `json:"fromAddress,omitempty"`
	Timestamp   *time.Time `json:"timestamp,omitempty"`
	TxID        *string    `json:"txID,omitempty"`
}

// EventType defines model for EventType.
type EventType string

// ExecuteTask defines model for ExecuteTask.
type ExecuteTask struct {
	AvailableGasBalance Token   `json:"availableGasBalance"`
	Message             Message `json:"message"`
	Payload             []byte  `json:"payload"`
}

// ExecuteTaskItem defines model for ExecuteTaskItem.
type ExecuteTaskItem struct {
	Task ExecuteTask `json:"task"`
}

// Fee defines model for Fee.
type Fee struct {
	Description *string      `json:"description,omitempty"`
	ID          string       `json:"id"`
	Meta        *FeeMetadata `json:"meta,omitempty"`
	Token       Token        `json:"token"`
}

// FeeMetadata defines model for FeeMetadata.
type FeeMetadata struct {
	TxID *string `json:"txID,omitempty"`
}

// Fees defines model for Fees.
type Fees = []Fee

// GasCreditEvent defines model for GasCreditEvent.
type GasCreditEvent struct {
	EventID       string         `json:"eventID"`
	MessageID     string         `json:"messageID"`
	Meta          *EventMetadata `json:"meta,omitempty"`
	Payment       Token          `json:"payment"`
	RefundAddress Address        `json:"refundAddress"`
}

// GasRefundedEvent defines model for GasRefundedEvent.
type GasRefundedEvent struct {
	Cost             Cost           `json:"cost"`
	EventID          string         `json:"eventID"`
	MessageID        string         `json:"messageID"`
	Meta             *EventMetadata `json:"meta,omitempty"`
	RecipientAddress Address        `json:"recipientAddress"`
	RefundedAmount   Token          `json:"refundedAmount"`
}

// GatewayTransactionTask defines model for GatewayTransactionTask.
type GatewayTransactionTask struct {
	ExecuteData []byte `json:"executeData"`
}

// GatewayTransactionTaskItem defines model for GatewayTransactionTaskItem.
type GatewayTransactionTaskItem struct {
	// Meta Metadata attached to GATEWAY_TX and REACT_TO_EXPIRED_SIGNING_SESSION tasks.
	// The property `scopedMessages` can be omitted if the task isn't associated with any message (e.g. when executing `rotateSigners` https://github.com/axelarnetwork/axelar-gmp-sdk-solidity/blob/432449d7b330ec6edf5a8e0746644a253486ca87/contracts/gateway/AxelarAmplifierGateway.sol#L103C14-L103C27).
	Meta *DestinationChainTaskMetadata `json:"meta,omitempty"`
	Task GatewayTransactionTask        `json:"task"`
}

// GetTasksResult defines model for GetTasksResult.
type GetTasksResult struct {
	Tasks []TaskEnvelope `json:"tasks"`
}

// ITSInterchainTokenDeploymentStartedEvent defines model for ITSInterchainTokenDeploymentStartedEvent.
type ITSInterchainTokenDeploymentStartedEvent struct {
	DestinationChain string                    `json:"destinationChain"`
	EventID          string                    `json:"eventID"`
	MessageID        string                    `json:"messageID"`
	Meta             *EventMetadata            `json:"meta,omitempty"`
	Token            InterchainTokenDefinition `json:"token"`
}

// ITSInterchainTransferEvent defines model for ITSInterchainTransferEvent.
type ITSInterchainTransferEvent struct {
	DataHash           []byte         `json:"dataHash"`
	DestinationAddress []byte         `json:"destinationAddress"`
	DestinationChain   string         `json:"destinationChain"`
	EventID            string         `json:"eventID"`
	MessageID          string         `json:"messageID"`
	Meta               *EventMetadata `json:"meta,omitempty"`
	SourceAddress      Address        `json:"sourceAddress"`
	TokenSpent         Token          `json:"tokenSpent"`
}

// ITSLinkTokenStartedEvent defines model for ITSLinkTokenStartedEvent.
type ITSLinkTokenStartedEvent struct {
	DestinationChain        string           `json:"destinationChain"`
	DestinationTokenAddress []byte           `json:"destinationTokenAddress"`
	EventID                 string           `json:"eventID"`
	MessageID               string           `json:"messageID"`
	Meta                    *EventMetadata   `json:"meta,omitempty"`
	SourceTokenAddress      []byte           `json:"sourceTokenAddress"`
	TokenID                 string           `json:"tokenID"`
	TokenManagerType        TokenManagerType `json:"tokenManagerType"`
}

// ITSTokenMetadataRegisteredEvent defines model for ITSTokenMetadataRegisteredEvent.
type ITSTokenMetadataRegisteredEvent struct {
	Address   Address        `json:"address"`
	Decimals  uint8          `json:"decimals"`
	EventID   string         `json:"eventID"`
	MessageID string         `json:"messageID"`
	Meta      *EventMetadata `json:"meta,omitempty"`
}

// InterchainTokenDefinition defines model for InterchainTokenDefinition.
type InterchainTokenDefinition struct {
	Decimals uint8  `json:"decimals"`
	ID       string `json:"id"`
	Name     string `json:"name"`
	Symbol   string `json:"symbol"`
}

// InterchainTransferToken defines model for InterchainTransferToken.
type InterchainTransferToken struct {
	Amount       BigInt  `json:"amount"`
	TokenAddress Address `json:"tokenAddress"`
}

// Keccak256Hash defines model for Keccak256Hash.
type Keccak256Hash = string

// Message defines model for Message.
type Message struct {
	DestinationAddress Address `json:"destinationAddress"`
	MessageID          string  `json:"messageID"`
	PayloadHash        []byte  `json:"payloadHash"`
	SourceAddress      Address `json:"sourceAddress"`
	SourceChain        string  `json:"sourceChain"`
}

// MessageApprovedEvent defines model for MessageApprovedEvent.
type MessageApprovedEvent struct {
	Cost    Cost                          `json:"cost"`
	EventID string                        `json:"eventID"`
	Message Message                       `json:"message"`
	Meta    *MessageApprovedEventMetadata `json:"meta,omitempty"`
}

// MessageApprovedEventMetadata defines model for MessageApprovedEventMetadata.
type MessageApprovedEventMetadata struct {
	CommandID   *string    `json:"commandID,omitempty"`
	Finalized   *bool      `json:"finalized,omitempty"`
	FromAddress *Address   `json:"fromAddress,omitempty"`
	Timestamp   *time.Time `json:"timestamp,omitempty"`
	TxID        *string    `json:"txID,omitempty"`
}

// MessageContext defines model for MessageContext.
type MessageContext map[string]string

// MessageExecutedEvent defines model for MessageExecutedEvent.
type MessageExecutedEvent struct {
	Cost        Cost                          `json:"cost"`
	EventID     string                        `json:"eventID"`
	MessageID   string                        `json:"messageID"`
	Meta        *MessageExecutedEventMetadata `json:"meta,omitempty"`
	SourceChain string                        `json:"sourceChain"`
	// Deprecated:
	Status MessageExecutionStatus `json:"status"`
}

// MessageExecutedEventMetadata defines model for MessageExecutedEventMetadata.
type MessageExecutedEventMetadata struct {
	ChildMessageIDs *[]string  `json:"childMessageIDs,omitempty"`
	CommandID       *string    `json:"commandID,omitempty"`
	Finalized       *bool      `json:"finalized,omitempty"`
	FromAddress     *Address   `json:"fromAddress,omitempty"`
	RevertReason    *string    `json:"revertReason,omitempty"`
	Timestamp       *time.Time `json:"timestamp,omitempty"`
	TxID            *string    `json:"txID,omitempty"`
}

// MessageExecutedEventV2 defines model for MessageExecutedEventV2.
type MessageExecutedEventV2 struct {
	Cost         Cost                          `json:"cost"`
	CrossChainID CrossChainID                  `json:"crossChainID"`
	EventID      string                        `json:"eventID"`
	Meta         *MessageExecutedEventMetadata `json:"meta,omitempty"`
}

// MessageExecutionStatus defines model for MessageExecutionStatus.
type MessageExecutionStatus string

// PublishEventAcceptedResult defines model for PublishEventAcceptedResult.
type PublishEventAcceptedResult struct {
	Index  int                `json:"index"`
	Status PublishEventStatus `json:"status"`
}

// PublishEventErrorResult defines model for PublishEventErrorResult.
type PublishEventErrorResult struct {
	Error     string             `json:"error"`
	Index     int                `json:"index"`
	Retriable bool               `json:"retriable"`
	Status    PublishEventStatus `json:"status"`
}

// PublishEventResultItem defines model for PublishEventResultItem.
type PublishEventResultItem struct {
	union json.RawMessage
}

// PublishEventResultItemBase defines model for PublishEventResultItemBase.
type PublishEventResultItemBase struct {
	Index  int                `json:"index"`
	Status PublishEventStatus `json:"status"`
}

// PublishEventStatus defines model for PublishEventStatus.
type PublishEventStatus string

// PublishEventsRequest defines model for PublishEventsRequest.
type PublishEventsRequest struct {
	Events []Event `json:"events"`
}

// PublishEventsResult defines model for PublishEventsResult.
type PublishEventsResult struct {
	Results []PublishEventResultItem `json:"results"`
}

// QuorumReachedEvent defines model for QuorumReachedEvent.
type QuorumReachedEvent struct {
	Content json.RawMessage    `json:"content"`
	Status  VerificationStatus `json:"status"`
}

// ReactToExpiredSigningSessionTask defines model for ReactToExpiredSigningSessionTask.
type ReactToExpiredSigningSessionTask struct {
	BroadcastID            BroadcastID `json:"broadcastID"`
	InvokedContractAddress Address     `json:"invokedContractAddress"`
	RequestPayload         WasmRequest `json:"requestPayload"`
	SessionID              uint64      `json:"sessionID"`
}

// ReactToExpiredSigningSessionTaskItem defines model for ReactToExpiredSigningSessionTaskItem.
type ReactToExpiredSigningSessionTaskItem struct {
	// Meta Metadata attached to GATEWAY_TX and REACT_TO_EXPIRED_SIGNING_SESSION tasks.
	// The property `scopedMessages` can be omitted if the task isn't associated with any message (e.g. when executing `rotateSigners` https://github.com/axelarnetwork/axelar-gmp-sdk-solidity/blob/432449d7b330ec6edf5a8e0746644a253486ca87/contracts/gateway/AxelarAmplifierGateway.sol#L103C14-L103C27).
	Meta *DestinationChainTaskMetadata    `json:"meta,omitempty"`
	Task ReactToExpiredSigningSessionTask `json:"task"`
}

// ReactToRetriablePollTask defines model for ReactToRetriablePollTask.
type ReactToRetriablePollTask struct {
	BroadcastID            BroadcastID          `json:"broadcastID"`
	InvokedContractAddress Address              `json:"invokedContractAddress"`
	PollID                 uint64               `json:"pollID"`
	QuorumReachedEvents    []QuorumReachedEvent `json:"quorumReachedEvents"`
	RequestPayload         WasmRequest          `json:"requestPayload"`
}

// ReactToRetriablePollTaskItem defines model for ReactToRetriablePollTaskItem.
type ReactToRetriablePollTaskItem struct {
	Task ReactToRetriablePollTask `json:"task"`
}

// ReactToWasmEventTask defines model for ReactToWasmEventTask.
type ReactToWasmEventTask struct {
	Event  WasmEvent `json:"event"`
	Height int64     `json:"height"`
}

// ReactToWasmEventTaskItem defines model for ReactToWasmEventTaskItem.
type ReactToWasmEventTaskItem struct {
	Task ReactToWasmEventTask `json:"task"`
}

// RefundTask defines model for RefundTask.
type RefundTask struct {
	Message                Message `json:"message"`
	RefundRecipientAddress Address `json:"refundRecipientAddress"`
	RemainingGasBalance    Token   `json:"remainingGasBalance"`
}

// RefundTaskItem defines model for RefundTaskItem.
type RefundTaskItem struct {
	// Meta Metadata attached to REFUND and VERIFY tasks. It carries values passed in the associated CALL event (if any) back to the source chain.
	Meta *SourceChainTaskMetadata `json:"meta,omitempty"`
	Task RefundTask               `json:"task"`
}

// SignersRotatedEvent defines model for SignersRotatedEvent.
type SignersRotatedEvent struct {
	EventID   string                       `json:"eventID"`
	MessageID string                       `json:"messageID"`
	Meta      *SignersRotatedEventMetadata `json:"meta,omitempty"`
}

// SignersRotatedEventMetadata defines model for SignersRotatedEventMetadata.
type SignersRotatedEventMetadata struct {
	Epoch       *int64     `json:"epoch,omitempty"`
	Finalized   *bool      `json:"finalized,omitempty"`
	FromAddress *Address   `json:"fromAddress,omitempty"`
	SignersHash *[]byte    `json:"signersHash,omitempty"`
	Timestamp   *time.Time `json:"timestamp,omitempty"`
	TxID        *string    `json:"txID,omitempty"`
}

// SourceChainTaskMetadata Metadata attached to REFUND and VERIFY tasks. It carries values passed in the associated CALL event (if any) back to the source chain.
type SourceChainTaskMetadata struct {
	SourceContext *MessageContext `json:"sourceContext,omitempty"`
}

// StorePayloadResult defines model for StorePayloadResult.
type StorePayloadResult struct {
	Keccak256 Keccak256Hash `json:"keccak256"`
}

// TaskEnvelope defines model for TaskEnvelope.
type TaskEnvelope struct {
	Chain     string     `json:"chain"`
	ID        TaskItemID `json:"id"`
	Task      TaskItem   `json:"task"`
	Timestamp time.Time  `json:"timestamp"`
}

// TaskItem defines model for TaskItem.
type TaskItem struct {
	Type  TaskType `json:"type"`
	union json.RawMessage
}

// TaskItemID defines model for TaskItemID.
type TaskItemID = uuid.UUID

// TaskType defines model for TaskType.
type TaskType string

// Token defines model for Token.
type Token struct {
	Amount  BigInt  `json:"amount"`
	TokenID *string `json:"tokenID,omitempty"`
}

// TokenManagerType defines model for TokenManagerType.
type TokenManagerType string

// VerificationStatus defines model for VerificationStatus.
type VerificationStatus string

// VerifyTask defines model for VerifyTask.
type VerifyTask struct {
	DestinationChain string  `json:"destinationChain"`
	Message          Message `json:"message"`
	Payload          []byte  `json:"payload"`
}

// VerifyTaskItem defines model for VerifyTaskItem.
type VerifyTaskItem struct {
	// Meta Metadata attached to REFUND and VERIFY tasks. It carries values passed in the associated CALL event (if any) back to the source chain.
	Meta *SourceChainTaskMetadata `json:"meta,omitempty"`
	Task VerifyTask               `json:"task"`
}

// WasmEvent defines model for WasmEvent.
type WasmEvent struct {
	Attributes []WasmEventAttribute `json:"attributes"`
	Type       string               `json:"type"`
}

// WasmEventAttribute defines model for WasmEventAttribute.
type WasmEventAttribute struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// WasmRequest defines model for WasmRequest.
type WasmRequest struct {
	union json.RawMessage
}

// WasmRequestWithObjectBody defines model for WasmRequestWithObjectBody.
type WasmRequestWithObjectBody map[string]interface{}

// WasmRequestWithStringBody defines model for WasmRequestWithStringBody.
type WasmRequestWithStringBody = string

// After defines model for after.
type After = uuid.UUID

// Chain defines model for chain.
type Chain = string

// Limit defines model for limit.
type Limit = int

// WasmContractAddress defines model for wasmContractAddress.
type WasmContractAddress = string

// GetTasksParams defines parameters for GetTasks.
type GetTasksParams struct {
	After *After `form:"after,omitempty" json:"after,omitempty"`
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// PublishEventsJSONRequestBody defines body for PublishEvents for application/json ContentType.
type PublishEventsJSONRequestBody = PublishEventsRequest

// BroadcastMsgExecuteContractJSONRequestBody defines body for BroadcastMsgExecuteContract for application/json ContentType.
type BroadcastMsgExecuteContractJSONRequestBody = WasmRequest

// QueryContractStateJSONRequestBody defines body for QueryContractState for application/json ContentType.
type QueryContractStateJSONRequestBody = WasmRequest

// AsToken returns the union data inside the Cost as a Token
func (t Cost) AsToken() (Token, error) {
	var (
		body Token
		err  error
	)

	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromToken overwrites any union data inside the Cost as the provided Token
func (t *Cost) FromToken(v Token) error {
	var err error
	var b []byte
	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeToken performs a merge with any union data inside the Cost, using the provided Token
func (t *Cost) MergeToken(v Token) error {
	var err error
	var b []byte
	var merged []byte
	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFees returns the union data inside the Cost as a Fees
func (t Cost) AsFees() (Fees, error) {
	var (
		body Fees
		err  error
	)

	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromFees overwrites any union data inside the Cost as the provided Fees
func (t *Cost) FromFees(v Fees) error {
	var err error
	var b []byte
	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeFees performs a merge with any union data inside the Cost, using the provided Fees
func (t *Cost) MergeFees(v Fees) error {
	var err error
	var b []byte
	var merged []byte
	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Cost) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Cost) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGasCreditEvent returns the union data inside the Event as a GasCreditEvent
func (t Event) AsGasCreditEvent() (GasCreditEvent, error) {
	var (
		body GasCreditEvent
		err  error
	)

	discriminator := t.Type
	if discriminator != "GAS_CREDIT" {
		return GasCreditEvent{}, fmt.Errorf("cannot cast Event to GasCreditEvent, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromGasCreditEvent overwrites any union data inside the Event as the provided GasCreditEvent
func (t *Event) FromGasCreditEvent(v GasCreditEvent) error {
	var err error
	var b []byte
	t.Type = "GAS_CREDIT"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeGasCreditEvent performs a merge with any union data inside the Event, using the provided GasCreditEvent
func (t *Event) MergeGasCreditEvent(v GasCreditEvent) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "GAS_CREDIT"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGasRefundedEvent returns the union data inside the Event as a GasRefundedEvent
func (t Event) AsGasRefundedEvent() (GasRefundedEvent, error) {
	var (
		body GasRefundedEvent
		err  error
	)

	discriminator := t.Type
	if discriminator != "GAS_REFUNDED" {
		return GasRefundedEvent{}, fmt.Errorf("cannot cast Event to GasRefundedEvent, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromGasRefundedEvent overwrites any union data inside the Event as the provided GasRefundedEvent
func (t *Event) FromGasRefundedEvent(v GasRefundedEvent) error {
	var err error
	var b []byte
	t.Type = "GAS_REFUNDED"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeGasRefundedEvent performs a merge with any union data inside the Event, using the provided GasRefundedEvent
func (t *Event) MergeGasRefundedEvent(v GasRefundedEvent) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "GAS_REFUNDED"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCallEvent returns the union data inside the Event as a CallEvent
func (t Event) AsCallEvent() (CallEvent, error) {
	var (
		body CallEvent
		err  error
	)

	discriminator := t.Type
	if discriminator != "CALL" {
		return CallEvent{}, fmt.Errorf("cannot cast Event to CallEvent, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromCallEvent overwrites any union data inside the Event as the provided CallEvent
func (t *Event) FromCallEvent(v CallEvent) error {
	var err error
	var b []byte
	t.Type = "CALL"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeCallEvent performs a merge with any union data inside the Event, using the provided CallEvent
func (t *Event) MergeCallEvent(v CallEvent) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "CALL"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMessageApprovedEvent returns the union data inside the Event as a MessageApprovedEvent
func (t Event) AsMessageApprovedEvent() (MessageApprovedEvent, error) {
	var (
		body MessageApprovedEvent
		err  error
	)

	discriminator := t.Type
	if discriminator != "MESSAGE_APPROVED" {
		return MessageApprovedEvent{}, fmt.Errorf("cannot cast Event to MessageApprovedEvent, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageApprovedEvent overwrites any union data inside the Event as the provided MessageApprovedEvent
func (t *Event) FromMessageApprovedEvent(v MessageApprovedEvent) error {
	var err error
	var b []byte
	t.Type = "MESSAGE_APPROVED"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageApprovedEvent performs a merge with any union data inside the Event, using the provided MessageApprovedEvent
func (t *Event) MergeMessageApprovedEvent(v MessageApprovedEvent) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "MESSAGE_APPROVED"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMessageExecutedEvent returns the union data inside the Event as a MessageExecutedEvent
func (t Event) AsMessageExecutedEvent() (MessageExecutedEvent, error) {
	var (
		body MessageExecutedEvent
		err  error
	)

	discriminator := t.Type
	if discriminator != "MESSAGE_EXECUTED" {
		return MessageExecutedEvent{}, fmt.Errorf("cannot cast Event to MessageExecutedEvent, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageExecutedEvent overwrites any union data inside the Event as the provided MessageExecutedEvent
func (t *Event) FromMessageExecutedEvent(v MessageExecutedEvent) error {
	var err error
	var b []byte
	t.Type = "MESSAGE_EXECUTED"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageExecutedEvent performs a merge with any union data inside the Event, using the provided MessageExecutedEvent
func (t *Event) MergeMessageExecutedEvent(v MessageExecutedEvent) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "MESSAGE_EXECUTED"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMessageExecutedEventV2 returns the union data inside the Event as a MessageExecutedEventV2
func (t Event) AsMessageExecutedEventV2() (MessageExecutedEventV2, error) {
	var (
		body MessageExecutedEventV2
		err  error
	)

	discriminator := t.Type
	if discriminator != "MESSAGE_EXECUTED/V2" {
		return MessageExecutedEventV2{}, fmt.Errorf("cannot cast Event to MessageExecutedEventV2, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageExecutedEventV2 overwrites any union data inside the Event as the provided MessageExecutedEventV2
func (t *Event) FromMessageExecutedEventV2(v MessageExecutedEventV2) error {
	var err error
	var b []byte
	t.Type = "MESSAGE_EXECUTED/V2"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageExecutedEventV2 performs a merge with any union data inside the Event, using the provided MessageExecutedEventV2
func (t *Event) MergeMessageExecutedEventV2(v MessageExecutedEventV2) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "MESSAGE_EXECUTED/V2"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCannotExecuteMessageEvent returns the union data inside the Event as a CannotExecuteMessageEvent
func (t Event) AsCannotExecuteMessageEvent() (CannotExecuteMessageEvent, error) {
	var (
		body CannotExecuteMessageEvent
		err  error
	)

	discriminator := t.Type
	if discriminator != "CANNOT_EXECUTE_MESSAGE" {
		return CannotExecuteMessageEvent{}, fmt.Errorf("cannot cast Event to CannotExecuteMessageEvent, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromCannotExecuteMessageEvent overwrites any union data inside the Event as the provided CannotExecuteMessageEvent
func (t *Event) FromCannotExecuteMessageEvent(v CannotExecuteMessageEvent) error {
	var err error
	var b []byte
	t.Type = "CANNOT_EXECUTE_MESSAGE"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeCannotExecuteMessageEvent performs a merge with any union data inside the Event, using the provided CannotExecuteMessageEvent
func (t *Event) MergeCannotExecuteMessageEvent(v CannotExecuteMessageEvent) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "CANNOT_EXECUTE_MESSAGE"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCannotExecuteMessageEventV2 returns the union data inside the Event as a CannotExecuteMessageEventV2
func (t Event) AsCannotExecuteMessageEventV2() (CannotExecuteMessageEventV2, error) {
	var (
		body CannotExecuteMessageEventV2
		err  error
	)

	discriminator := t.Type
	if discriminator != "CANNOT_EXECUTE_MESSAGE/V2" {
		return CannotExecuteMessageEventV2{}, fmt.Errorf("cannot cast Event to CannotExecuteMessageEventV2, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromCannotExecuteMessageEventV2 overwrites any union data inside the Event as the provided CannotExecuteMessageEventV2
func (t *Event) FromCannotExecuteMessageEventV2(v CannotExecuteMessageEventV2) error {
	var err error
	var b []byte
	t.Type = "CANNOT_EXECUTE_MESSAGE/V2"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeCannotExecuteMessageEventV2 performs a merge with any union data inside the Event, using the provided CannotExecuteMessageEventV2
func (t *Event) MergeCannotExecuteMessageEventV2(v CannotExecuteMessageEventV2) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "CANNOT_EXECUTE_MESSAGE/V2"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCannotRouteMessageEvent returns the union data inside the Event as a CannotRouteMessageEvent
func (t Event) AsCannotRouteMessageEvent() (CannotRouteMessageEvent, error) {
	var (
		body CannotRouteMessageEvent
		err  error
	)

	discriminator := t.Type
	if discriminator != "CANNOT_ROUTE_MESSAGE" {
		return CannotRouteMessageEvent{}, fmt.Errorf("cannot cast Event to CannotRouteMessageEvent, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromCannotRouteMessageEvent overwrites any union data inside the Event as the provided CannotRouteMessageEvent
func (t *Event) FromCannotRouteMessageEvent(v CannotRouteMessageEvent) error {
	var err error
	var b []byte
	t.Type = "CANNOT_ROUTE_MESSAGE"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeCannotRouteMessageEvent performs a merge with any union data inside the Event, using the provided CannotRouteMessageEvent
func (t *Event) MergeCannotRouteMessageEvent(v CannotRouteMessageEvent) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "CANNOT_ROUTE_MESSAGE"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCannotExecuteTaskEvent returns the union data inside the Event as a CannotExecuteTaskEvent
func (t Event) AsCannotExecuteTaskEvent() (CannotExecuteTaskEvent, error) {
	var (
		body CannotExecuteTaskEvent
		err  error
	)

	discriminator := t.Type
	if discriminator != "CANNOT_EXECUTE_TASK" {
		return CannotExecuteTaskEvent{}, fmt.Errorf("cannot cast Event to CannotExecuteTaskEvent, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromCannotExecuteTaskEvent overwrites any union data inside the Event as the provided CannotExecuteTaskEvent
func (t *Event) FromCannotExecuteTaskEvent(v CannotExecuteTaskEvent) error {
	var err error
	var b []byte
	t.Type = "CANNOT_EXECUTE_TASK"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeCannotExecuteTaskEvent performs a merge with any union data inside the Event, using the provided CannotExecuteTaskEvent
func (t *Event) MergeCannotExecuteTaskEvent(v CannotExecuteTaskEvent) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "CANNOT_EXECUTE_TASK"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSignersRotatedEvent returns the union data inside the Event as a SignersRotatedEvent
func (t Event) AsSignersRotatedEvent() (SignersRotatedEvent, error) {
	var (
		body SignersRotatedEvent
		err  error
	)

	discriminator := t.Type
	if discriminator != "SIGNERS_ROTATED" {
		return SignersRotatedEvent{}, fmt.Errorf("cannot cast Event to SignersRotatedEvent, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignersRotatedEvent overwrites any union data inside the Event as the provided SignersRotatedEvent
func (t *Event) FromSignersRotatedEvent(v SignersRotatedEvent) error {
	var err error
	var b []byte
	t.Type = "SIGNERS_ROTATED"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeSignersRotatedEvent performs a merge with any union data inside the Event, using the provided SignersRotatedEvent
func (t *Event) MergeSignersRotatedEvent(v SignersRotatedEvent) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "SIGNERS_ROTATED"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsITSLinkTokenStartedEvent returns the union data inside the Event as a ITSLinkTokenStartedEvent
func (t Event) AsITSLinkTokenStartedEvent() (ITSLinkTokenStartedEvent, error) {
	var (
		body ITSLinkTokenStartedEvent
		err  error
	)

	discriminator := t.Type
	if discriminator != "ITS/LINK_TOKEN_STARTED" {
		return ITSLinkTokenStartedEvent{}, fmt.Errorf("cannot cast Event to ITSLinkTokenStartedEvent, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromITSLinkTokenStartedEvent overwrites any union data inside the Event as the provided ITSLinkTokenStartedEvent
func (t *Event) FromITSLinkTokenStartedEvent(v ITSLinkTokenStartedEvent) error {
	var err error
	var b []byte
	t.Type = "ITS/LINK_TOKEN_STARTED"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeITSLinkTokenStartedEvent performs a merge with any union data inside the Event, using the provided ITSLinkTokenStartedEvent
func (t *Event) MergeITSLinkTokenStartedEvent(v ITSLinkTokenStartedEvent) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "ITS/LINK_TOKEN_STARTED"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsITSTokenMetadataRegisteredEvent returns the union data inside the Event as a ITSTokenMetadataRegisteredEvent
func (t Event) AsITSTokenMetadataRegisteredEvent() (ITSTokenMetadataRegisteredEvent, error) {
	var (
		body ITSTokenMetadataRegisteredEvent
		err  error
	)

	discriminator := t.Type
	if discriminator != "ITS/TOKEN_METADATA_REGISTERED" {
		return ITSTokenMetadataRegisteredEvent{}, fmt.Errorf("cannot cast Event to ITSTokenMetadataRegisteredEvent, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromITSTokenMetadataRegisteredEvent overwrites any union data inside the Event as the provided ITSTokenMetadataRegisteredEvent
func (t *Event) FromITSTokenMetadataRegisteredEvent(v ITSTokenMetadataRegisteredEvent) error {
	var err error
	var b []byte
	t.Type = "ITS/TOKEN_METADATA_REGISTERED"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeITSTokenMetadataRegisteredEvent performs a merge with any union data inside the Event, using the provided ITSTokenMetadataRegisteredEvent
func (t *Event) MergeITSTokenMetadataRegisteredEvent(v ITSTokenMetadataRegisteredEvent) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "ITS/TOKEN_METADATA_REGISTERED"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsITSInterchainTokenDeploymentStartedEvent returns the union data inside the Event as a ITSInterchainTokenDeploymentStartedEvent
func (t Event) AsITSInterchainTokenDeploymentStartedEvent() (ITSInterchainTokenDeploymentStartedEvent, error) {
	var (
		body ITSInterchainTokenDeploymentStartedEvent
		err  error
	)

	discriminator := t.Type
	if discriminator != "ITS/INTERCHAIN_TOKEN_DEPLOYMENT_STARTED" {
		return ITSInterchainTokenDeploymentStartedEvent{}, fmt.Errorf("cannot cast Event to ITSInterchainTokenDeploymentStartedEvent, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromITSInterchainTokenDeploymentStartedEvent overwrites any union data inside the Event as the provided ITSInterchainTokenDeploymentStartedEvent
func (t *Event) FromITSInterchainTokenDeploymentStartedEvent(v ITSInterchainTokenDeploymentStartedEvent) error {
	var err error
	var b []byte
	t.Type = "ITS/INTERCHAIN_TOKEN_DEPLOYMENT_STARTED"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeITSInterchainTokenDeploymentStartedEvent performs a merge with any union data inside the Event, using the provided ITSInterchainTokenDeploymentStartedEvent
func (t *Event) MergeITSInterchainTokenDeploymentStartedEvent(v ITSInterchainTokenDeploymentStartedEvent) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "ITS/INTERCHAIN_TOKEN_DEPLOYMENT_STARTED"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsITSInterchainTransferEvent returns the union data inside the Event as a ITSInterchainTransferEvent
func (t Event) AsITSInterchainTransferEvent() (ITSInterchainTransferEvent, error) {
	var (
		body ITSInterchainTransferEvent
		err  error
	)

	discriminator := t.Type
	if discriminator != "ITS/INTERCHAIN_TRANSFER" {
		return ITSInterchainTransferEvent{}, fmt.Errorf("cannot cast Event to ITSInterchainTransferEvent, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromITSInterchainTransferEvent overwrites any union data inside the Event as the provided ITSInterchainTransferEvent
func (t *Event) FromITSInterchainTransferEvent(v ITSInterchainTransferEvent) error {
	var err error
	var b []byte
	t.Type = "ITS/INTERCHAIN_TRANSFER"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeITSInterchainTransferEvent performs a merge with any union data inside the Event, using the provided ITSInterchainTransferEvent
func (t *Event) MergeITSInterchainTransferEvent(v ITSInterchainTransferEvent) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "ITS/INTERCHAIN_TRANSFER"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAppInterchainTransferSentEvent returns the union data inside the Event as a AppInterchainTransferSentEvent
func (t Event) AsAppInterchainTransferSentEvent() (AppInterchainTransferSentEvent, error) {
	var (
		body AppInterchainTransferSentEvent
		err  error
	)

	discriminator := t.Type
	if discriminator != "APP/INTERCHAIN_TRANSFER_SENT" {
		return AppInterchainTransferSentEvent{}, fmt.Errorf("cannot cast Event to AppInterchainTransferSentEvent, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppInterchainTransferSentEvent overwrites any union data inside the Event as the provided AppInterchainTransferSentEvent
func (t *Event) FromAppInterchainTransferSentEvent(v AppInterchainTransferSentEvent) error {
	var err error
	var b []byte
	t.Type = "APP/INTERCHAIN_TRANSFER_SENT"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeAppInterchainTransferSentEvent performs a merge with any union data inside the Event, using the provided AppInterchainTransferSentEvent
func (t *Event) MergeAppInterchainTransferSentEvent(v AppInterchainTransferSentEvent) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "APP/INTERCHAIN_TRANSFER_SENT"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAppInterchainTransferReceivedEvent returns the union data inside the Event as a AppInterchainTransferReceivedEvent
func (t Event) AsAppInterchainTransferReceivedEvent() (AppInterchainTransferReceivedEvent, error) {
	var (
		body AppInterchainTransferReceivedEvent
		err  error
	)

	discriminator := t.Type
	if discriminator != "APP/INTERCHAIN_TRANSFER_RECEIVED" {
		return AppInterchainTransferReceivedEvent{}, fmt.Errorf("cannot cast Event to AppInterchainTransferReceivedEvent, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppInterchainTransferReceivedEvent overwrites any union data inside the Event as the provided AppInterchainTransferReceivedEvent
func (t *Event) FromAppInterchainTransferReceivedEvent(v AppInterchainTransferReceivedEvent) error {
	var err error
	var b []byte
	t.Type = "APP/INTERCHAIN_TRANSFER_RECEIVED"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeAppInterchainTransferReceivedEvent performs a merge with any union data inside the Event, using the provided AppInterchainTransferReceivedEvent
func (t *Event) MergeAppInterchainTransferReceivedEvent(v AppInterchainTransferReceivedEvent) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "APP/INTERCHAIN_TRANSFER_RECEIVED"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Event) Discriminator() (string, error) {
	return string(t.Type), nil
	// Fallback to unmarshaling from union if no property found
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Event) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "APP/INTERCHAIN_TRANSFER_RECEIVED":
		return t.AsAppInterchainTransferReceivedEvent()
	case "APP/INTERCHAIN_TRANSFER_SENT":
		return t.AsAppInterchainTransferSentEvent()
	case "CALL":
		return t.AsCallEvent()
	case "CANNOT_EXECUTE_MESSAGE":
		return t.AsCannotExecuteMessageEvent()
	case "CANNOT_EXECUTE_MESSAGE/V2":
		return t.AsCannotExecuteMessageEventV2()
	case "CANNOT_EXECUTE_TASK":
		return t.AsCannotExecuteTaskEvent()
	case "CANNOT_ROUTE_MESSAGE":
		return t.AsCannotRouteMessageEvent()
	case "GAS_CREDIT":
		return t.AsGasCreditEvent()
	case "GAS_REFUNDED":
		return t.AsGasRefundedEvent()
	case "ITS/INTERCHAIN_TOKEN_DEPLOYMENT_STARTED":
		return t.AsITSInterchainTokenDeploymentStartedEvent()
	case "ITS/INTERCHAIN_TRANSFER":
		return t.AsITSInterchainTransferEvent()
	case "ITS/LINK_TOKEN_STARTED":
		return t.AsITSLinkTokenStartedEvent()
	case "ITS/TOKEN_METADATA_REGISTERED":
		return t.AsITSTokenMetadataRegisteredEvent()
	case "MESSAGE_APPROVED":
		return t.AsMessageApprovedEvent()
	case "MESSAGE_EXECUTED":
		return t.AsMessageExecutedEvent()
	case "MESSAGE_EXECUTED/V2":
		return t.AsMessageExecutedEventV2()
	case "SIGNERS_ROTATED":
		return t.AsSignersRotatedEvent()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Event) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Event) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsPublishEventAcceptedResult returns the union data inside the PublishEventResultItem as a PublishEventAcceptedResult
func (t PublishEventResultItem) AsPublishEventAcceptedResult() (PublishEventAcceptedResult, error) {
	var (
		body PublishEventAcceptedResult
		err  error
	)

	discriminator, err := t.Discriminator()
	if err != nil {
		return PublishEventAcceptedResult{}, fmt.Errorf("failed to get discriminator: %w", err)
	}

	if discriminator != "ACCEPTED" {
		return PublishEventAcceptedResult{}, fmt.Errorf("cannot cast PublishEventResultItem to PublishEventAcceptedResult, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromPublishEventAcceptedResult overwrites any union data inside the PublishEventResultItem as the provided PublishEventAcceptedResult
func (t *PublishEventResultItem) FromPublishEventAcceptedResult(v PublishEventAcceptedResult) error {
	var err error
	var b []byte

	// Add discriminator to the JSON data
	vMap := make(map[string]interface{})
	vBytes, err := json.Marshal(v)
	if err != nil {
		return err
	}
	err = json.Unmarshal(vBytes, &vMap)
	if err != nil {
		return err
	}
	vMap["Status"] = "ACCEPTED"
	b, err = json.Marshal(vMap)
	t.union = b
	return err

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergePublishEventAcceptedResult performs a merge with any union data inside the PublishEventResultItem, using the provided PublishEventAcceptedResult
func (t *PublishEventResultItem) MergePublishEventAcceptedResult(v PublishEventAcceptedResult) error {
	var err error
	var b []byte
	var merged []byte

	// Add discriminator to the JSON data
	vMap := make(map[string]interface{})
	vBytes, err := json.Marshal(v)
	if err != nil {
		return err
	}
	err = json.Unmarshal(vBytes, &vMap)
	if err != nil {
		return err
	}
	vMap["Status"] = "ACCEPTED"
	b, err = json.Marshal(vMap)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPublishEventErrorResult returns the union data inside the PublishEventResultItem as a PublishEventErrorResult
func (t PublishEventResultItem) AsPublishEventErrorResult() (PublishEventErrorResult, error) {
	var (
		body PublishEventErrorResult
		err  error
	)

	discriminator, err := t.Discriminator()
	if err != nil {
		return PublishEventErrorResult{}, fmt.Errorf("failed to get discriminator: %w", err)
	}

	if discriminator != "ERROR" {
		return PublishEventErrorResult{}, fmt.Errorf("cannot cast PublishEventResultItem to PublishEventErrorResult, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromPublishEventErrorResult overwrites any union data inside the PublishEventResultItem as the provided PublishEventErrorResult
func (t *PublishEventResultItem) FromPublishEventErrorResult(v PublishEventErrorResult) error {
	var err error
	var b []byte

	// Add discriminator to the JSON data
	vMap := make(map[string]interface{})
	vBytes, err := json.Marshal(v)
	if err != nil {
		return err
	}
	err = json.Unmarshal(vBytes, &vMap)
	if err != nil {
		return err
	}
	vMap["Status"] = "ERROR"
	b, err = json.Marshal(vMap)
	t.union = b
	return err

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergePublishEventErrorResult performs a merge with any union data inside the PublishEventResultItem, using the provided PublishEventErrorResult
func (t *PublishEventResultItem) MergePublishEventErrorResult(v PublishEventErrorResult) error {
	var err error
	var b []byte
	var merged []byte

	// Add discriminator to the JSON data
	vMap := make(map[string]interface{})
	vBytes, err := json.Marshal(v)
	if err != nil {
		return err
	}
	err = json.Unmarshal(vBytes, &vMap)
	if err != nil {
		return err
	}
	vMap["Status"] = "ERROR"
	b, err = json.Marshal(vMap)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PublishEventResultItem) Discriminator() (string, error) {
	// Fallback to unmarshaling from union if no property found
	var discriminator struct {
		Discriminator string `json:"status"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PublishEventResultItem) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ACCEPTED":
		return t.AsPublishEventAcceptedResult()
	case "ERROR":
		return t.AsPublishEventErrorResult()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PublishEventResultItem) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PublishEventResultItem) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsConstructProofTaskItem returns the union data inside the TaskItem as a ConstructProofTaskItem
func (t TaskItem) AsConstructProofTaskItem() (ConstructProofTaskItem, error) {
	var (
		body ConstructProofTaskItem
		err  error
	)

	discriminator := t.Type
	if discriminator != "CONSTRUCT_PROOF" {
		return ConstructProofTaskItem{}, fmt.Errorf("cannot cast TaskItem to ConstructProofTaskItem, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromConstructProofTaskItem overwrites any union data inside the TaskItem as the provided ConstructProofTaskItem
func (t *TaskItem) FromConstructProofTaskItem(v ConstructProofTaskItem) error {
	var err error
	var b []byte
	t.Type = "CONSTRUCT_PROOF"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeConstructProofTaskItem performs a merge with any union data inside the TaskItem, using the provided ConstructProofTaskItem
func (t *TaskItem) MergeConstructProofTaskItem(v ConstructProofTaskItem) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "CONSTRUCT_PROOF"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsExecuteTaskItem returns the union data inside the TaskItem as a ExecuteTaskItem
func (t TaskItem) AsExecuteTaskItem() (ExecuteTaskItem, error) {
	var (
		body ExecuteTaskItem
		err  error
	)

	discriminator := t.Type
	if discriminator != "EXECUTE" {
		return ExecuteTaskItem{}, fmt.Errorf("cannot cast TaskItem to ExecuteTaskItem, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromExecuteTaskItem overwrites any union data inside the TaskItem as the provided ExecuteTaskItem
func (t *TaskItem) FromExecuteTaskItem(v ExecuteTaskItem) error {
	var err error
	var b []byte
	t.Type = "EXECUTE"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeExecuteTaskItem performs a merge with any union data inside the TaskItem, using the provided ExecuteTaskItem
func (t *TaskItem) MergeExecuteTaskItem(v ExecuteTaskItem) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "EXECUTE"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGatewayTransactionTaskItem returns the union data inside the TaskItem as a GatewayTransactionTaskItem
func (t TaskItem) AsGatewayTransactionTaskItem() (GatewayTransactionTaskItem, error) {
	var (
		body GatewayTransactionTaskItem
		err  error
	)

	discriminator := t.Type
	if discriminator != "GATEWAY_TX" {
		return GatewayTransactionTaskItem{}, fmt.Errorf("cannot cast TaskItem to GatewayTransactionTaskItem, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromGatewayTransactionTaskItem overwrites any union data inside the TaskItem as the provided GatewayTransactionTaskItem
func (t *TaskItem) FromGatewayTransactionTaskItem(v GatewayTransactionTaskItem) error {
	var err error
	var b []byte
	t.Type = "GATEWAY_TX"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeGatewayTransactionTaskItem performs a merge with any union data inside the TaskItem, using the provided GatewayTransactionTaskItem
func (t *TaskItem) MergeGatewayTransactionTaskItem(v GatewayTransactionTaskItem) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "GATEWAY_TX"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReactToWasmEventTaskItem returns the union data inside the TaskItem as a ReactToWasmEventTaskItem
func (t TaskItem) AsReactToWasmEventTaskItem() (ReactToWasmEventTaskItem, error) {
	var (
		body ReactToWasmEventTaskItem
		err  error
	)

	discriminator := t.Type
	if discriminator != "REACT_TO_WASM_EVENT" {
		return ReactToWasmEventTaskItem{}, fmt.Errorf("cannot cast TaskItem to ReactToWasmEventTaskItem, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromReactToWasmEventTaskItem overwrites any union data inside the TaskItem as the provided ReactToWasmEventTaskItem
func (t *TaskItem) FromReactToWasmEventTaskItem(v ReactToWasmEventTaskItem) error {
	var err error
	var b []byte
	t.Type = "REACT_TO_WASM_EVENT"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeReactToWasmEventTaskItem performs a merge with any union data inside the TaskItem, using the provided ReactToWasmEventTaskItem
func (t *TaskItem) MergeReactToWasmEventTaskItem(v ReactToWasmEventTaskItem) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "REACT_TO_WASM_EVENT"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRefundTaskItem returns the union data inside the TaskItem as a RefundTaskItem
func (t TaskItem) AsRefundTaskItem() (RefundTaskItem, error) {
	var (
		body RefundTaskItem
		err  error
	)

	discriminator := t.Type
	if discriminator != "REFUND" {
		return RefundTaskItem{}, fmt.Errorf("cannot cast TaskItem to RefundTaskItem, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromRefundTaskItem overwrites any union data inside the TaskItem as the provided RefundTaskItem
func (t *TaskItem) FromRefundTaskItem(v RefundTaskItem) error {
	var err error
	var b []byte
	t.Type = "REFUND"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeRefundTaskItem performs a merge with any union data inside the TaskItem, using the provided RefundTaskItem
func (t *TaskItem) MergeRefundTaskItem(v RefundTaskItem) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "REFUND"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReactToExpiredSigningSessionTaskItem returns the union data inside the TaskItem as a ReactToExpiredSigningSessionTaskItem
func (t TaskItem) AsReactToExpiredSigningSessionTaskItem() (ReactToExpiredSigningSessionTaskItem, error) {
	var (
		body ReactToExpiredSigningSessionTaskItem
		err  error
	)

	discriminator := t.Type
	if discriminator != "REACT_TO_EXPIRED_SIGNING_SESSION" {
		return ReactToExpiredSigningSessionTaskItem{}, fmt.Errorf("cannot cast TaskItem to ReactToExpiredSigningSessionTaskItem, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromReactToExpiredSigningSessionTaskItem overwrites any union data inside the TaskItem as the provided ReactToExpiredSigningSessionTaskItem
func (t *TaskItem) FromReactToExpiredSigningSessionTaskItem(v ReactToExpiredSigningSessionTaskItem) error {
	var err error
	var b []byte
	t.Type = "REACT_TO_EXPIRED_SIGNING_SESSION"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeReactToExpiredSigningSessionTaskItem performs a merge with any union data inside the TaskItem, using the provided ReactToExpiredSigningSessionTaskItem
func (t *TaskItem) MergeReactToExpiredSigningSessionTaskItem(v ReactToExpiredSigningSessionTaskItem) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "REACT_TO_EXPIRED_SIGNING_SESSION"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReactToRetriablePollTaskItem returns the union data inside the TaskItem as a ReactToRetriablePollTaskItem
func (t TaskItem) AsReactToRetriablePollTaskItem() (ReactToRetriablePollTaskItem, error) {
	var (
		body ReactToRetriablePollTaskItem
		err  error
	)

	discriminator := t.Type
	if discriminator != "REACT_TO_RETRIABLE_POLL" {
		return ReactToRetriablePollTaskItem{}, fmt.Errorf("cannot cast TaskItem to ReactToRetriablePollTaskItem, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromReactToRetriablePollTaskItem overwrites any union data inside the TaskItem as the provided ReactToRetriablePollTaskItem
func (t *TaskItem) FromReactToRetriablePollTaskItem(v ReactToRetriablePollTaskItem) error {
	var err error
	var b []byte
	t.Type = "REACT_TO_RETRIABLE_POLL"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeReactToRetriablePollTaskItem performs a merge with any union data inside the TaskItem, using the provided ReactToRetriablePollTaskItem
func (t *TaskItem) MergeReactToRetriablePollTaskItem(v ReactToRetriablePollTaskItem) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "REACT_TO_RETRIABLE_POLL"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVerifyTaskItem returns the union data inside the TaskItem as a VerifyTaskItem
func (t TaskItem) AsVerifyTaskItem() (VerifyTaskItem, error) {
	var (
		body VerifyTaskItem
		err  error
	)

	discriminator := t.Type
	if discriminator != "VERIFY" {
		return VerifyTaskItem{}, fmt.Errorf("cannot cast TaskItem to VerifyTaskItem, discriminator is %s", discriminator)
	}
	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromVerifyTaskItem overwrites any union data inside the TaskItem as the provided VerifyTaskItem
func (t *TaskItem) FromVerifyTaskItem(v VerifyTaskItem) error {
	var err error
	var b []byte
	t.Type = "VERIFY"

	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeVerifyTaskItem performs a merge with any union data inside the TaskItem, using the provided VerifyTaskItem
func (t *TaskItem) MergeVerifyTaskItem(v VerifyTaskItem) error {
	var err error
	var b []byte
	var merged []byte
	t.Type = "VERIFY"

	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TaskItem) Discriminator() (string, error) {
	return string(t.Type), nil
	// Fallback to unmarshaling from union if no property found
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t TaskItem) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "CONSTRUCT_PROOF":
		return t.AsConstructProofTaskItem()
	case "EXECUTE":
		return t.AsExecuteTaskItem()
	case "GATEWAY_TX":
		return t.AsGatewayTransactionTaskItem()
	case "REACT_TO_EXPIRED_SIGNING_SESSION":
		return t.AsReactToExpiredSigningSessionTaskItem()
	case "REACT_TO_RETRIABLE_POLL":
		return t.AsReactToRetriablePollTaskItem()
	case "REACT_TO_WASM_EVENT":
		return t.AsReactToWasmEventTaskItem()
	case "REFUND":
		return t.AsRefundTaskItem()
	case "VERIFY":
		return t.AsVerifyTaskItem()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t TaskItem) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *TaskItem) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsWasmRequestWithObjectBody returns the union data inside the WasmRequest as a WasmRequestWithObjectBody
func (t WasmRequest) AsWasmRequestWithObjectBody() (WasmRequestWithObjectBody, error) {
	var (
		body WasmRequestWithObjectBody
		err  error
	)

	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromWasmRequestWithObjectBody overwrites any union data inside the WasmRequest as the provided WasmRequestWithObjectBody
func (t *WasmRequest) FromWasmRequestWithObjectBody(v WasmRequestWithObjectBody) error {
	var err error
	var b []byte
	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeWasmRequestWithObjectBody performs a merge with any union data inside the WasmRequest, using the provided WasmRequestWithObjectBody
func (t *WasmRequest) MergeWasmRequestWithObjectBody(v WasmRequestWithObjectBody) error {
	var err error
	var b []byte
	var merged []byte
	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWasmRequestWithStringBody returns the union data inside the WasmRequest as a WasmRequestWithStringBody
func (t WasmRequest) AsWasmRequestWithStringBody() (WasmRequestWithStringBody, error) {
	var (
		body WasmRequestWithStringBody
		err  error
	)

	err = json.Unmarshal(t.union, &body)
	return body, err
}

// FromWasmRequestWithStringBody overwrites any union data inside the WasmRequest as the provided WasmRequestWithStringBody
func (t *WasmRequest) FromWasmRequestWithStringBody(v WasmRequestWithStringBody) error {
	var err error
	var b []byte
	b, err = json.Marshal(v)
	t.union = b
	return err
}

// MergeWasmRequestWithStringBody performs a merge with any union data inside the WasmRequest, using the provided WasmRequestWithStringBody
func (t *WasmRequest) MergeWasmRequestWithStringBody(v WasmRequestWithStringBody) error {
	var err error
	var b []byte
	var merged []byte
	b, err = json.Marshal(v)
	if err != nil {
		return err
	}
	merged, err = runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t WasmRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *WasmRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
